---
title: Query strategy performance
---

This page discusses the requirements of the various data access modules of the Phenoscape application to be demonstrated at the ASIH workshop, and documents the performance of the various [[Queries#Proposed_querying_strategies_for_the_ASIH_prototype|querying strategies]] being tested for these modules. Familiary with SQL and PostgreSQL stored procedures may be necessary to fully comprehend these contents. 

= Anatomy data services =

Given a specific anatomical entity A, the requirements of the anatomy data service module are as follows:

# Identify ALL unique phenotypes {P} that are composed of the entity A or any of its subtypes.
# For each identified phenotype P which is of the form inheres_in(Q, E)
## Identify the quality Q.
### In addition, identify the character C which subsumes Q. This requires navigating the PATO hierarchy recursively in some cases
## Identify the entity E. E may be the same as A, or any valid subtype of A.
## Identify the set of taxa {T} or genotypes {GT} that exhibit the phenotype P.
### For a genotype GT, identify the gene G that encodes it.

The result should be a list in the format shown below

<javascript>
<Search-Anatomical-Entity>         <Phenotype>             <Entity>         <Quality>    <Character>      <List of taxa>OR<List of genes>
</javascript>


==Strategy #1==

This strategy is the [[Queries#Strategy_#1:_Simple_table_joins|simplest way]] to try and get all the necessary information related to the anatomical entity being searched for. Below is the actual query which attempts to do this. This query returns the unique phenotypes associated with the anatomical entity, and the qualities and specific anatomical entities associated with the phenotype, as well as the list of taxa that exhibit each of these phenotypes in one fell table join (uh, swoop).

===Query 1 (keep it simple, no stored procedure invocations) ===
<sql>
SELECT DISTINCT
phenotype_node.uid AS phenotype,
taxon_node.uid AS taxon,
quality_node.uid AS quality,
anatomy_node.uid AS entity
FROM
link AS inheres_in_link, link AS search_link, link AS is_a_link,
link AS exhibits_link,
node AS taxon_node, node AS exhibits_pred_node, node AS phenotype_node,
node AS search_pred_node, node AS search_node,
node AS inheres_in_pred_node, node AS anatomy_node,
node AS is_a_pred_node, node AS quality_node
WHERE
exhibits_pred_node.uid = 'PHENOSCAPE:exhibits' AND
is_a_pred_node.uid = 'OBO_REL:is_a' AND
inheres_in_pred_node.uid = 'OBO_REL:inheres_in' AND
search_pred_node.uid = 'OBO_REL:inheres_in' AND
search_node.uid = 'TAO:0000108' AND
inheres_in_link.is_inferred = 'f' AND
is_a_link.is_inferred = 'f' AND
exhibits_link.node_id IS NOT NULL AND
search_link.node_id = phenotype_node.node_id AND
search_link.predicate_id = search_pred_node.node_id AND
search_link.object_id = search_node.node_id AND
inheres_in_link.node_id = phenotype_node.node_id AND
inheres_in_link.predicate_id = inheres_in_pred_node.node_id AND
inheres_in_link.object_id = anatomy_node.node_id AND
is_a_link.node_id = phenotype_node.node_id AND
is_a_link.predicate_id = is_a_pred_node.node_id AND
is_a_link.object_id = quality_node.node_id AND
exhibits_link.node_id = taxon_node.node_id AND
exhibits_link.predicate_id = exhibits_pred_node.node_id AND
exhibits_link.object_id = phenotype_node.node_id;
</sql>

====Query Execution Plan====


====Execution Details====
* Rows returned: 968
* Phenoscape data revision: 449
* Time: 0.25 ~ 9 s

====Discussion====

This query (referred to as QfS1, short for "Query for Strategy 1") returns each phenotype associated with the 'TAO:0000108' and also the specific entities and qualities associated with each phenotype. In addition, the taxa that exhibit the phenotype and the genotypes are also returned. If several taxa {T} or genotypes (GT} exhibit the same phenotype P, which is of the form, inheres_in(Q, E), the results are returned in rows in the format shown below.

<javascript>
P1                   E1                Q1                   T1
P1                   E1                Q1                   T2
.
.
P1                   E1                Q1                   Tn
P2                   E2                Q2                   GT1
.
.
P2                   E2                Q2                   GTn
</javascript>

Note that for each quality Q in the result above, the character that subsumes it needs to be determined. This cannot be done directly from the query because a recursive traversal of the PATO hierarchy may be required in many cases. Recursive traversals are best implemented by stored procedures. This will definitely add to the execution times documented for this query. Further, note that only the genotypes associated with each phenotype are returned. To find the genes that encode these genotypes, another query needs to be executed. It is not possible to unilaterally join this gene query with QfS1 because both taxa as well as genotypes are returned by QfS1. What is required is a procedural attachment that invokes the gene query if the returned result is a genotype. Again, this procedural attachment can only be implemented as a stored procedure.

Finally, the performance of the query QfS1 varied widely from 0.25 (very good) to 9 seconds (mildly acceptable) in a random set of executions issued from the command line. The query [[Queries#Factor_2:_Query_parsing_and_execution_planning|execution planning process]] is responsible for this. If instead of searching for 'TAO:0000108' (fin), a more general term (like TAO:0100000, the parent term for all term definitions in TAO) were to be searched for, the performance of this query would be much more unpredictable and much slower too.

===Query 2 (Bring on the stored procedures, some of them to start)===

Let us examine the performance of the very same query where specific stored procedures for identifying the characters subsuming the qualities and genes encoding the genotypes are invoked as part of QfS1.

<sql>
SELECT DISTINCT
phenotype_node.uid AS phenotype,
quality_node.uid AS quality_id,
quality_node.label AS quality,
getAttributeForQuality(quality_node.node_id) AS attribute,
anatomy_node.uid AS entity_id,
anatomy_node.label AS entity,
getTaxaForPhenotype(phenotype_node.node_id) AS taxonOrGene
FROM
link AS inheres_in_link, link AS search_link, link AS is_a_link,
link AS exhibits_link,
node AS taxon_node,
node AS exhibits_pred_node,
node AS phenotype_node,
node AS search_pred_node, node AS search_node,
node AS inheres_in_pred_node, node AS anatomy_node,
node AS is_a_pred_node, node AS quality_node
WHERE
exhibits_pred_node.uid = 'PHENOSCAPE:exhibits' AND
is_a_pred_node.uid = 'OBO_REL:is_a' AND
inheres_in_pred_node.uid = 'OBO_REL:inheres_in' AND
search_pred_node.uid = 'OBO_REL:inheres_in' AND
search_node.uid = 'TAO:0000108' AND
inheres_in_link.is_inferred = 'f' AND
is_a_link.is_inferred = 'f' AND
exhibits_link.node_id IS NOT NULL AND
search_link.node_id = phenotype_node.node_id AND
search_link.predicate_id = search_pred_node.node_id AND
search_link.object_id = search_node.node_id AND
inheres_in_link.node_id = phenotype_node.node_id AND
inheres_in_link.predicate_id = inheres_in_pred_node.node_id AND
inheres_in_link.object_id = anatomy_node.node_id AND
is_a_link.node_id = phenotype_node.node_id AND
is_a_link.predicate_id = is_a_pred_node.node_id AND
is_a_link.object_id = quality_node.node_id AND
exhibits_link.node_id = taxon_node.node_id AND
exhibits_link.predicate_id = exhibits_pred_node.node_id AND
exhibits_link.object_id = phenotype_node.node_id;
</sql>

====Execution Details====
* Rows returned: 69
* Execution time: 7 - 30 seconds

====Discussion====

This query returns all the required information for an input anatomical entity. Note the taxa or genes exhibiting or responsible for a specific phenotype are all grouped together in one row with the said phenotype. The character which subsumes the quality of a phenotype is retrieved as well. But since 13 tables are joined together, query execution planning may still be a significant cause to the unpredictable and relatively slow performance of this query. Moreover, note these results are being obtained for a query for fin. If the query was for TAO:0100000, the root term of TAO, the performance would be much slower and unpredictable.

==Strategy #2==

This strategy tries to save on query execution planning times by specifying the [[Queries#Strategy_#2:_Specifying_the_order_of_table_joins_in_the_original_query|order of table joins in the query itself]].

===Query===
<sql>
SELECT DISTINCT
phenotype_node.uid AS phenotype,
quality_node.uid AS quality_id,
quality_node.label AS quality,
getAttributeForQuality(quality_node.node_id) AS attribute,
anatomy_node.uid AS entity_id,
anatomy_node.label AS entity,
getTaxaForPhenotype(phenotype_node.node_id) AS taxonOrGene
FROM
link AS inheres_in_link, link AS is_a_link,
node AS taxon_node
INNER JOIN link AS exhibits_link
INNER JOIN node AS phenotype_node
INNER JOIN link AS search_link
INNER JOIN node AS search_node
ON (search_link.object_id = search_node.node_id)
ON (phenotype_node.node_id = search_link.node_id)
ON (exhibits_link.object_id = phenotype_node.node_id)
ON (taxon_node.node_id = exhibits_link.node_id),
node AS exhibits_pred_node,
node AS search_pred_node,
node AS inheres_in_pred_node, node AS anatomy_node,
node AS is_a_pred_node, node AS quality_node
WHERE
exhibits_pred_node.uid = 'PHENOSCAPE:exhibits' AND
is_a_pred_node.uid = 'OBO_REL:is_a' AND
inheres_in_pred_node.uid = 'OBO_REL:inheres_in' AND
search_pred_node.uid = 'OBO_REL:inheres_in' AND
search_node.uid = 'TAO:0000108' AND
inheres_in_link.is_inferred = 'f' AND
is_a_link.is_inferred = 'f' AND
exhibits_link.node_id IS NOT NULL AND
search_link.node_id = phenotype_node.node_id AND
search_link.predicate_id = search_pred_node.node_id AND
search_link.object_id = search_node.node_id AND
inheres_in_link.node_id = phenotype_node.node_id AND
inheres_in_link.predicate_id = inheres_in_pred_node.node_id AND
inheres_in_link.object_id = anatomy_node.node_id AND
is_a_link.node_id = phenotype_node.node_id AND
is_a_link.predicate_id = is_a_pred_node.node_id AND
is_a_link.object_id = quality_node.node_id AND
exhibits_link.node_id = taxon_node.node_id AND
exhibits_link.predicate_id = exhibits_pred_node.node_id AND
exhibits_link.object_id = phenotype_node.node_id;
</sql>

===Execution details===

* Rows returned: 69
* Execution time: 9.8 seconds

===Discussion===

The results obtained by this query are consistent with the requirements of the anatomy data service. The query performance is also very stable (approx. 9.8 seconds) over repeated executions. In the next section, the stored procedures used in this query viz. ''getTaxaForPhenotype(INT)'' and ''getAttributeForQuality(INT)'' will be discussed along with a comprehensive stored procedure called ''getAnatomyInfoWithTableJoins(VARCHAR)'' that can be invoked from the client side and in its turn, invokes the other stored procedures to return all the data related to the searched anatomical entity in one execution.

==Strategy #3==

==Strategy #4==

==Strategy #5==

= Gene data services =

= Taxon data services =

= Publication data services =